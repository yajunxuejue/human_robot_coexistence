/* Author: Liao Yajun */
#ifndef INCORPORATEDSMAPF_H
#define INCORPORATEDSMAPF_H

#include <Eigen/Geometry>

/**
  \brief Incorporating the method of dyanimcial system modulation and repulsive vector field to generate reactive
  motion for a robot treated as a control point.
*/
class IncorporateDsmApf{
private:
  ///output velocity which can avoid collide with obstacles
  Eigen::Vector3f modulated_velocity;
  ///input the repulsive vector that denotes the direction of away from the obstacles
  Eigen::Vector3f repulsive_vector;
  ///constructing the modulation matrix
  Eigen::Matrix3f modulation_matrix;
  ///direction between repulsive vector and raw command speed, true means the control point is approaching the obstacle surface.
  bool direction_repvector_rawspeed;
  ///the minimum distance between obstacle and control point
  float min_distance;

  /**
      \brief Find out whether the control point is approaching the obstacle or away from it.

      \param rep_vector. Input the reuplsive vector denoted the direction of approaching obstacle surface.
      \param raw_speed. Input the raw speed generated by dynamical system.
      \return direction_repvector_rawspeed.
      time is unlimited. True means the control point is approaching the obstacle surface, in contrast, it is false.
    */
  bool getDirection(Eigen::Vector3f &rep_vector, Eigen::Vector3f &raw_speed_);

  /**
      \brief Fetch the modulated velocity

      \return modulated_velocity.
    */
  Eigen::Vector3f getModulatedVelocity() const;

public:
  /**
      \brief Construct a object for utilizing the mothod of combining dynamicial system and repulsive vector field.

      \param repulsive_vector_.
      \param raw_velocity_.
      \param min_distance_. Optional timeout for connecting to action servers. If it is not specified, the wait
      time is unlimited.
    */
  IncorporateDsmApf(Eigen::Vector3f &repulsive_vector_, Eigen::Vector3f & raw_velocity_, float & min_distance_);
  /**
      \brief Construct a client for the MoveGroup action using a specified set of options \e opt.

      \param opt. A MoveGroup::Options structure, if you pass a ros::NodeHandle with a specific callback queue, it has
     to be of type ros::CallbackQueue
        (which is the default type of callback queues used in ROS)
      \param tf. Specify a TF instance to use. If not specified, one will be constructed internally.
      \param wait_for_servers. Optional timeout for connecting to action servers. If it is not specified, the wait
      time is unlimited.
    */
  void calculateModulatedVelocity(const Eigen::Vector3f &raw_speed_);
  /**
      \brief Construct a client for the MoveGroup action using a specified set of options \e opt.

      \param opt. A MoveGroup::Options structure, if you pass a ros::NodeHandle with a specific callback queue, it has
     to be of type ros::CallbackQueue
        (which is the default type of callback queues used in ROS)
      \param tf. Specify a TF instance to use. If not specified, one will be constructed internally.
      \param wait_for_servers. Optional timeout for connecting to action servers. If it is not specified, the wait
      time is unlimited.
    */
  void calculateModulationMatrix(Eigen::Vector3f & repulsive_vec);
  /**
      \brief Construct a client for the MoveGroup action using a specified set of options \e opt.

      \param opt. A MoveGroup::Options structure, if you pass a ros::NodeHandle with a specific callback queue, it has
     to be of type ros::CallbackQueue
        (which is the default type of callback queues used in ROS)
      \param tf. Specify a TF instance to use. If not specified, one will be constructed internally.
      \param wait_for_servers. Optional timeout for connecting to action servers. If it is not specified, the wait
      time is unlimited.
    */
  float calculateMagunitude(float & distance);

  ~IncorporateDsmApf();
};
#endif
